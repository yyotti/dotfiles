[[plugins]]
repo = 'Shougo/neomru.vim'

[[plugins]]
repo = 'Shougo/vimproc.vim'
if = '!IsWindows()'
build = 'make'
on_source = [ 'unite.vim', 'vim-ref' ]

[[plugins]]
repo = 'Shougo/neocomplete.vim'
depends = 'context_filetype.vim'
if = 'has("lua")'
on_event = 'InsertEnter'
hook_source = '''
  let g:neocomplete#enable_at_startup = 1
  source ~/.vim/rc/plugins/neocomplete.rc.vim
'''

[[plugins]]
repo = 'Shougo/neosnippet.vim'
depends = [ 'neosnippet-snippets', 'context_filetype.vim' ]
on_event = 'InsertCharPre'
on_ft = 'snippet'
hook_source = '''
  imap <silent> <C-k> <Plug>(neosnippet_jump_or_expand)
  smap <silent> <C-k> <Plug>(neosnippet_jump_or_expand)
  xmap <silent> <C-k> <Plug>(neosnippet_expand_target)
  imap <silent> <C-l> <Plug>(neosnippet_expand_or_jump)
  smap <silent> <C-l> <Plug>(neosnippet_expand_or_jump)
  xmap <silent> o <Plug>(neosnippet_register_oneshot_snippet)

  let g:neosnippet#enable_snipmate_compatibility = 1
  let g:neosnippet#enable_completed_snippet = 1
  let g:neosnippet#expand_word_boundary = 1

  if !exists('g:neosnippet#snippets_directory')
    let g:neosnippet#snippets_directory = ''
  endif

  let s:snippets_dir = '~/.vim/snippets'
  let s:dirs = split(g:neosnippet#snippets_directory, ',')
  let s:found = 0
  for s:dir in s:dirs
    if s:dir ==# s:snippets_dir
      let s:found = 1
    endif
  endfor

  if !s:found
    let g:neosnippet#snippets_directory = join(add(s:dirs, s:snippets_dir), ',')
  endif

  unlet s:dirs
  unlet s:snippets_dir
'''

[[plugins]]
repo = 'yyotti/neosnippet-additional'
depends = 'neosnippet.vim'
on_ft = 'php'
hook_source = '''
  if !exists('g:neosnippet#snippets_directory')
    let g:neosnippet#snippets_directory = ''
  endif

  let s:snippets_dir =
        \ expand(dein#get('neosnippet-additional').path . '/snippets/')
  let s:dirs = split(g:neosnippet#snippets_directory, ',')
  let s:found = 0
  for s:dir in s:dirs
    if s:dir ==# s:snippets_dir
      let s:found = 1
    endif

    unlet s:dir
  endfor

  if !s:found
    let g:neosnippet#snippets_directory =
          \ join(add(s:dirs, s:snippets_dir), ',')
  endif

  unlet s:dirs
  unlet s:snippets_dir
'''

[[plugins]]
repo = 'Shougo/unite.vim'
depends = 'neomru.vim'
on_source = 'denite.vim'
hook_add = '''
  if !has('nvim') && v:version < 800
    nnoremap <silent> <Leader>ub :<C-u>Unite buffer file_mru<CR>
    nnoremap <silent> <Leader>uf
          \ :<C-u>Unite -buffer-name=files -no-split -multi-line -unique -silent
          \   `finddir('.git', ';') !=# '' ? 'file_rec/git' : ''`
          \     buffer_tab:- file file/new<CR>
    nnoremap <silent> <Leader>ul :<C-u>Unite line<CR>
    nnoremap <silent> <Leader>ug
          \ :<C-u>Unite grep -buffer-name=grep -no-start-insert -no-empty<CR>
    nnoremap <silent> <Leader>ur
          \ :<C-u>UniteResume -buffer-name=grep
          \   -no-start-insert -no-empty grep<CR>
    nnoremap <silent> <Leader>ue :<C-u>Unite menu:_<CR>

    nnoremap <silent> <Leader>n :<C-u>UniteNext<CR>
    nnoremap <silent> <Leader>p :<C-u>UnitePrevious<CR>
  endif
'''
hook_source = 'source ~/.vim/rc/plugins/unite.rc.vim'

[[plugins]]
repo = 'Shougo/denite.nvim'
on_cmd = 'Denite'
if = 'has("nvim") || v:version >= 800'
hook_add = '''
  nnoremap <silent> <Leader>ub :<C-u>Denite buffer file_old<CR>
  nnoremap <silent> <Leader>uf :<C-u>Denite file_rec<CR>
  nnoremap <silent> <Leader>ul :<C-u>Denite line<CR>
  nnoremap <silent> <Leader>ug
        \ :<C-u>Denite grep -mode=normal -no-empty -buffer-name=grep<CR>
  nnoremap <silent> <Leader>ur
        \ :<C-u>Denite -resume -mode=normal -no-empty -buffer-name=grep<CR>
  nnoremap <silent> <Leader>ue :<C-u>Denite menu:_<CR>

  nnoremap <silent> <Leader>n
        \ :<C-u>Denite -resume -select=+1 -immediately -buffer-name=grep<CR>
  nnoremap <silent> <Leader>p
        \ :<C-u>Denite -resume -select=-1 -immediately -buffer-name=grep<CR>
'''
hook_source = 'source ~/.vim/rc/plugins/denite.rc.vim'

[[plugins]]
repo = 'Shougo/context_filetype.vim'

[[plugins]]
repo = 'Shougo/vimfiler.vim'
depends = 'unite.vim'
on_map = { n = '<Plug>' }
on_if = 'isdirectory(bufname("%"))'
hook_add = '''
  nnoremap <silent> <Leader>fe
        \ :<C-u>VimFilerBufferDir -invisible<CR>
'''
hook_source = '''
  call vimfiler#custom#profile('default', 'context', {
        \   'save': 0,
        \   'parent': 0,
        \ })

  let g:vimfiler_as_default_explorer = 1
  if IsWindows()
    let g:vimfiler_detect_drives = [
          \   'C:/', 'D:/', 'E:/', 'F:/', 'G:/',
          \   'H:/', 'I:/', 'J:/', 'K:/', 'L:/',
          \   'M:/', 'N:/',
          \ ]

    let g:unite_kind_file_use_trashbox = 1
  endif

  let g:vimfiler_force_overwrite_statusline = 0

  autocmd MyAutocmd FileType vimfiler call <SID>vimfiler_settings()
  function! s:vimfiler_settings() abort
    call vimfiler#set_execute_file('vim', [ 'nvim', 'vim', 'notepad' ])
    call vimfiler#set_execute_file('txt', [ 'nvim', 'vim', 'notepad' ])
  endfunction
'''

[[plugins]]
repo = 'Shougo/junkfile.vim'
on_source = 'unite.vim'
hook_add = '''
  nnoremap <silent> <Leader>uj :<C-u>Unite junkfile/new junkfile<CR>
'''

[[plugins]]
repo = 'Shougo/neco-vim'
on_ft = 'vim'

[[plugins]]
repo = 'LeafCage/foldCC.vim'
on_ft = 'vim'
hook_add = '''
  let g:foldCCtext_enable_autofdc_adjuster = 1
  set foldtext=FoldCCtext()
'''

[[plugins]]
repo = 'thinca/vim-ref'
if = 'executable("lynx")'
on_map = { n = '<Plug>' }
hook_add = '''
  nmap K <Plug>(ref-keyword)
'''
hook_source = '''
  let g:ref_cache_dir = expand('$CACHE/vim_ref_cache')
  let g:ref_use_vimproc = 1
  if IsWindows()
    let g:ref_refe_encoding = 'cp932'
  endif

  let g:ref_lynx_use_cache = 1
  let g:ref_lynx_start_linenumber = 0
  let g:ref_lynx_hide_url_number = 0

  " PHP
  let g:ref_phpmanual_path = $HOME . '/.vim/refs/php-chunked-xhtml'

  autocmd MyAutocmd FileType ref nnoremap <silent> <buffer> q :q<CR>
'''

[[plugins]]
repo = 'tyru/eskk.vim'
on_map = { ic = '<Plug>' }
hook_add = '''
  imap <C-j> <Plug>(eskk:toggle)
  cmap <C-j> <Plug>(eskk:toggle)
'''
hook_source = '''
  let g:eskk#directory = expand('~/.skk')
  let g:eskk#debug = 0
  let g:eskk#show_annotation = 1

  " User dic
  let g:eskk#dictionary = {
        \   'path': g:eskk#directory . '/skk-jisyo.user',
        \   'sorted': 0,
        \   'encoding': 'utf-8',
        \ }

  let g:eskk#large_dictionary = {
        \   'path': g:eskk#directory . '/SKK-JISYO.L',
        \   'sorted': 1,
        \   'encoding': 'euc-jp',
        \ }
  " google-ime-skk
  if executable('google-ime-skk')
    let g:eskk#server = {
          \   'host': 'localhost',
          \   'port': 55100,
          \   'type': 'dictionary',
          \ }
  endif

  autocmd MyAutocmd User eskk-initialize-pre call s:eskk_initial_pre()
  function! s:eskk_initial_pre() abort "{{{
    let t = eskk#table#new('rom_to_hira*', 'rom_to_hira')
    call t.add_map('z ', "\u3000")
    call t.add_map('z(', "\uff08")
    call t.add_map('z)', "\uff09")
    call t.add_map('~', "\u301c")
    call eskk#register_mode_table('hira', t)
    unlet t
  endfunction "}}}
'''

[[plugins]]
repo = 'tyru/open-browser.vim'

[[plugins]]
repo = 'kana/vim-operator-replace'
depends = 'vim-operator-user'
on_map = '<Plug>'
hook_add = '''
  map R <Plug>(operator-replace)
  xmap p <Plug>(operator-replace)
'''

[[plugins]]
repo = 'rhysd/vim-operator-surround'
depends = 'vim-operator-user'
on_map = { n = '<Plug>' }
hook_add = '''
  map <silent> ra <Plug>(operator-surround-append)
  map <silent> rd <Plug>(operator-surround-delete)
  map <silent> rc <Plug>(operator-surround-replace)
'''

[[plugins]]
repo = 'airblade/vim-gitgutter'
on_path = '.*'
hook_source = '''
  let g:gitgutter_sign_added = 'A'
  let g:gitgutter_sign_modified = 'M'
  let g:gitgutter_sign_removed = 'D'
  let g:gitgutter_sign_modified_removed = 'MD'

  let g:gitgutter_map_keys = 0
  let g:gitgutter_async = 0

  nmap [c <Plug>GitGutterPrevHunkzvzz
  nmap ]c <Plug>GitGutterNextHunkzvzz
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
depends = 'vim-repeat'
on_map = { nxo = '<Plug>' }
hook_add = '''
  let g:EasyMotion_smartcase = 1
  let g:EasyMotion_enter_jump_first = 1
  let g:EasyMotion_space_jump_first = 1
  let g:EasyMotion_startofline = 0
  let g:EasyMotion_verbose = 0

  map ' <Plug>(easymotion-prefix)

  map f <Plug>(easymotion-fl)
  map t <Plug>(easymotion-tl)
  map F <Plug>(easymotion-Fl)
  map T <Plug>(easymotion-Tl)

  map ; <Plug>(easymotion-next)
  map , <Plug>(easymotion-prev)

  map 'f <Plug>(easymotion-fln)
  map 't <Plug>(easymotion-tln)
  map 'F <Plug>(easymotion-Fln)
  map 'T <Plug>(easymotion-Tln)
'''

[[plugins]]
repo = 'vim-scripts/sudo.vim'
if = '!IsWindows()'
on_path = 'sudo:.*'

[[plugins]]
repo = 'cohama/agit.vim'
# on_path = [ 'Agit', 'AgitFile' ]
hook_add = '''
  nnoremap <silent> <Leader>ga :<C-u>Agit<CR>
  nnoremap <silent> <Leader>gf :<C-u>AgitFile<CR>
'''

[[plugins]]
repo = 'simeji/winresizer'
hook_add = '''
  if has('gui_running')
    let g:winresizer_gui_enable = 1
    nnoremap <C-w>R :<C-u>WinResizerStartResizeGUI<CR>
  endif

  let g:winresizer_vert_resize = 5
  nnoremap <C-w>r :<C-u>WinResizerStartResize<CR>
'''
hook_post_source = '''
  execute 'unmap' g:winresizer_start_key
  if has('gui_running')
    execute 'unmap' g:winresizer_gui_start_key
  endif
'''

# [[plugins]]
# repo = 'lilydjwg/colorizer'
# on_ft = [ 'smarty', 'html', 'css', 'php' ]
# hook_add = 'let g:colorizer_nomap = 1'

[[plugins]]
repo = 'neomake/neomake'
if = 'has("nvim") || v:version >= 800'
hook_add = '''
  autocmd MyAutocmd BufWritePost * Neomake | call lightline#update()

  let g:neomake_scss_scsslint_maker = {
        \   'exe': 'scss-lint',
        \   'errorformat': '%A%f:%l [%t] %m',
        \ }

  " Vimscript
  if !IsWindows()
    let g:neomake_vim_enabled_makers = [ 'vimlint' ]
    let g:neomake_vim_vimlint_maker = {
          \   'exe': expand('~/.vim/script/vimlint.sh'),
          \   'args': [ '-u' ],
          \   'errorformat': '%f:%l:%c:%trror: %m,%f:%l:%c:%tarning: %m,%f:%l:%c:%m',
          \ }
  endif

  " TOML
  let g:neomake_toml_enabled_makers = [ 'tomlv' ]
  let g:neomake_toml_tomlv_maker = {
        \   'exe': 'tomlv',
        \   'errorformat': 'Error\ in\ ''%f'':\ Near\ line\ %l\ %m',
        \ }
'''
hook_post_source = '''
  highlight link NeomakeErrorSign ErrorMsg
'''

[[plugins]]
repo = 'osyo-manga/shabadou.vim'
if = '!has("nvim") && v:version < 800'

[[plugins]]
repo = 'osyo-manga/vim-watchdogs'
depends = [ 'vim-quickrun', 'vimproc.vim', 'shabadou.vim' ]
if = '!has("nvim") && v:version < 800'
on_path = '.*'
hook_source = '''
  let g:watchdogs_check_BufWritePost_enable = 1
  let g:watchdogs_check_BufWritePost_enable_on_wq = 0

  if !exists('g:quickrun_config')
    let g:quickrun_config = {}
  endif
  if !has_key(g:quickrun_config, 'watchdogs_checker/_')
    let g:quickrun_config['watchdogs_checker/_'] = {}
  endif
  let g:quickrun_config['watchdogs_checker/_']['hook/close_quickfix/enable_exit'] = 1

  if executable('tomlv')
    " TOML
    if !has_key(g:quickrun_config, 'toml/watchdogs_checker')
      let g:quickrun_config['toml/watchdogs_checker'] = {}
    endif
    let g:quickrun_config['toml/watchdogs_checker']['type'] =
          \ 'watchdogs_checker/tomlv'
    if !has_key(g:quickrun_config, 'watchdogs_checker/tomlv')
      let g:quickrun_config['watchdogs_checker/tomlv'] = {
            \   'command': 'tomlv',
            \   'exec': '%c %s:p',
            \   'quickfix/errorformat':
            \     '%trror\ in\ ''%f'':\ Near\ line\ %l\ %m',
            \ }
    endif
  endif
'''
hook_post_source = 'call watchdogs#setup(g:quickrun_config)'

[[plugins]]
repo = 'KazuakiM/vim-qfstatusline'
if = '!has("nvim") && v:version < 800'
on_source = 'vim-watchdogs'
hook_source = '''
  if !exists('g:quickrun_config')
    let g:quickrun_config = {}
  endif
  if !has_key(g:quickrun_config, 'watchdogs_checker/_')
    let g:quickrun_config['watchdogs_checker/_'] = {}
  endif
  let g:quickrun_config['watchdogs_checker/_']['hook/back_window/enable_exit'] = 0
  let g:quickrun_config['watchdogs_checker/_']['hook/back_window/priority_exit'] = 1
  let g:quickrun_config['watchdogs_checker/_']['hook/qfstatusline_update/enable_exit'] = 1
  let g:quickrun_config['watchdogs_checker/_']['hook/qfstatusline_update/priority_exit'] = 2

  let g:Qfstatusline#Text = 0
'''
hook_post_source = '''
  let g:Qfstatusline#UpdateCmd = exists('*lightline#update') ?
        \ function('lightline#update') : function('qfstatusline#Update')
'''

[[plugins]]
repo = 'KazuakiM/vim-qfsigns'
if = '!has("nvim") && v:version < 800'
on_source = 'vim-watchdogs'
hook_source = '''
  if !exists('g:quickrun_config')
    let g:quickrun_config = {}
  endif
  if !has_key(g:quickrun_config, 'watchdogs_checker/_')
    let g:quickrun_config['watchdogs_checker/_'] = {}
  endif
  let g:quickrun_config['watchdogs_checker/_']['hook/back_window/enable_exit'] = 0
  let g:quickrun_config['watchdogs_checker/_']['hook/back_window/priority_exit'] = 1
  let g:quickrun_config['watchdogs_checker/_']['hook/qfstatusline_update/enable_exit'] = 1
  let g:quickrun_config['watchdogs_checker/_']['hook/qfstatusline_update/priority_exit'] = 2

  let g:Qfstatusline#Text = 0
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
on_map = { n = '<Plug>' }
hook_add = 'nmap <silent> <Leader>r <Plug>(quickrun)'

[[plugins]]
repo = 'haya14busa/vim-operator-flashy'
depends = 'vim-operator-user'
on_map = { nx = '<Plug>' }
hook_add = '''
  let g:operator#flashy#flash_time = 300
  map y <Plug>(operator-flashy)
  nmap Y <Plug>(operator-flashy)$
'''
hook_post_source = '''
  highlight Flashy ctermbg=8 guibg=#666666
'''

[[plugins]]
repo = 'yyotti/vim-autoupload'
on_path = '.*'
hook_add = '''
  autocmd MyAutocmd BufWinEnter *.php,*.tpl,*.css,*.js
        \ call autoupload#init(0)
  autocmd MyAutocmd BufWritePost *.php,*.tpl,*.css,*.js
        \ call autoupload#upload(0)
'''

[[plugins]]
repo = 'benjifisher/matchit.zip'
on_map = { nxo = [ '%', 'g%' ] }
hook_source = '''
  if exists('g:loaded_matchit')
    unlet g:loaded_matchit
  endif
'''
hook_post_source = '''
  silent! execute 'doautocmd FileType' &filetype
'''

[[plugins]]
repo = 'syngan/vim-vimlint'
depends = [ 'vim-vimlparser' ]
on_source = 'vim-watchdogs'

[[plugins]]
repo = 'ynkdir/vim-vimlparser'

[[plugins]]
repo = 'osyo-manga/vim-precious'
depends = 'context_filetype.vim'
on_event = 'InsertEnter'
hook_source = '''
  let g:precious_enable_switch_CursorMoved = { '*': 0 }
  autocmd MyAutocmd InsertEnter * PreciousSwitch
  autocmd MyAutocmd InsertLeave * PreciousReset
'''

[[plugins]]
repo = 'AndrewRadev/linediff.vim'

[[plugins]]
repo = 'adoy/vim-php-refactoring-toolbox'
on_ft = [ 'php' ]
hook_add = '''
  let g:vim_php_refactoring_use_default_mapping = 0
'''
hook_source = '''
  nnoremap <silent> rflv :call PhpRenameLocalVariable()<CR>
  nnoremap <silent> rfcv :call PhpRenameClassVariable()<CR>
  nnoremap <silent> rfrm :call PhpRenameMethod()<CR>
  nnoremap <silent> rfdu :call PhpDetectUnusedUseStatements()<CR>
  nnoremap <silent> rfec :call PhpExtractClassProperty()<CR>
  nnoremap <silent> rfeu :call PhpExtractUse()<CR>

  vnoremap <silent> rfem :call PhpExtractMethod()<CR>
  vnoremap <silent> <Leader>== :call PhpAlignAssigns()<CR>
'''

[[plugins]]
repo = 'tyru/caw.vim'
depends = [ 'vim-operator-user', 'vim-repeat' ]
on_map = { nx = '<Plug>' }
hook_add = '''
  function! InitCaw() abort "{{{
    if !&l:modifiable
      silent! nunmap <buffer> gc
      silent! xunmap <buffer> gc
      silent! nunmap <buffer> gcc
      silent! xunmap <buffer> gcc
    else
      nmap <buffer> gc <Plug>(caw:prefix)
      xmap <buffer> gc <Plug>(caw:prefix)
      nmap <buffer> gcc <Plug>(caw:hatpos:toggle)
      xmap <buffer> gcc <Plug>(caw:hatpos:toggle)
    endif

  endfunction "}}}

  autocmd MyAutocmd FileType * call InitCaw()
  call InitCaw()

  let g:caw_operator_keymappings = 1
'''
hook_source = '''
  silent! execute 'doautocmd FileType' &filetype
'''

[[plugins]]
repo = 'cohama/lexima.vim'
on_event = 'InsertEnter'
hook_post_source = '''
  if exists('*lexima#insmode#leave')
    inoremap <C-f> <C-r>=lexima#insmode#leave(1, '<LT>C-G>U<LT>RIGHT>')<CR>
  endif
'''

[[plugins]]
repo = 'ciaranm/securemodelines'
on_event = 'BufRead'
hook_add = '''
  set modelines=0
  set nomodeline
'''
