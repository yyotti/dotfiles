[[plugins]]
repo = 'vim-airline/vim-airline'
on_event = 'VimEnter' # lazy...?
hook_add = '''
let g:airline_skip_empty_sections = 1
let g:airline#extensions#languageclient#enabled = 0

if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

let g:airline_symbols.maxlinenr = ''
let g:airline_left_sep = "\u2b80"
let g:airline_left_alt_sep = "\u2b81"
let g:airline_right_sep = "\u2b82"
let g:airline_right_alt_sep = "\u2b83"

let g:airline_symbols.linenr = "\u2b61"
let g:airline_symbols.readonly = "\u2b64"
let g:airline_symbols.branch = "\u2b60"
'''
hook_source = '''
" Extension settings
if dein#tap('ale')
  let g:airline#extensions#ale#error_symbol = 'E'
  let g:airline#extensions#ale#warning_symbol = 'W'
endif

if dein#tap('vim-gitgutter')
  let g:airline#extensions#hunks#non_zero_only = 1
  let g:airline#extensions#hunks#hunk_symbols = [
        \   g:gitgutter_sign_added,
        \   g:gitgutter_sign_modified,
        \   g:gitgutter_sign_removed,
        \ ]
endif

if dein#tap('eskk.vim')
  function! EskkMode() abort "{{{
    return exists('*eskk#statusline') && !empty(eskk#statusline()) ?
          \ matchlist(eskk#statusline(), '^\[eskk:\(.\+\)\]$')[1] : ''
  endfunction "}}}
  call airline#parts#define_function('eskk', 'EskkMode')
endif

call airline#parts#define('lineinfo', {
      \   'raw': ' %3v %{g:airline_symbols.linenr}%3l/%L',
      \ })

autocmd MyAutocmd User AirlineAfterInit call <SID>airline_init()
function! s:airline_init() abort "{{{
  let l:section_b = []
  call add(l:section_b, 'hunks')

  if dein#tap('gina.vim')
    call add(l:section_b, '%{gina#component#repo#branch()}')
  endif

  let g:airline_section_a = airline#section#create_left([ 'mode', 'eskk' ])
  let g:airline_section_b = airline#section#create(l:section_b)
  let g:airline_section_z = airline#section#create([ 'windowswap', 'obsession', 'lineinfo' ])
endfunction "}}}
'''

[[plugins]]
repo = 'vim-airline/vim-airline-themes'
on_source = 'vim-airline'

[[plugins]]
repo = 'itchyny/vim-parenmatch'
if = 'v:version == 704 && has("patch786") || v:version >= 705 || has("nvim")'
on_path = '.*'

[[plugins]]
repo = 'tyru/caw.vim'
on_map = { nx = '<Plug>' }
hook_add = '''
nmap gc <Plug>(caw:prefix)
xmap gc <Plug>(caw:prefix)
'''

[[plugins]]
repo = 'lambdalisue/gina.vim'
on_map = { n = '<Plug>' }
hook_add = '''
let g:gina#command#status#use_default_mappings = 0

" TODO ステータス画面の開き方
" TODO branchやtagはdeniteと連携できないか？
nnoremap <silent> <Leader>gs :<C-u>Gina status<CR>
nnoremap <silent> <Leader>gb :<C-u>Gina branch<CR>
nnoremap <silent> <Leader>gd :<C-u>Gina compare<CR>
'''
hook_post_source = '''
execute 'source' vimrc#join_path($VIMDIR, 'rc/plugins/gina.rc.vim')
'''

[[plugins]]
repo = 'Shougo/denite.nvim'
hook_add = '''
nnoremap <silent> ;b :<C-u>Denite buffer file/old<CR>
nnoremap <silent> ;f :<C-u>Denite `finddir('.git', ';') != '' ?
      \  'file/rec/git' :
      \  'file/rec'` file file:new<CR>
nnoremap <silent> ;l :<C-u>Denite -auto-highlight line<CR>
nnoremap <silent> ;g
      \ :<C-u>Denite grep -mode=normal -no-empty -buffer-name=grep<CR>
nnoremap <silent> ;r
      \ :<C-u>Denite -resume -mode=normal -no-empty -buffer-name=grep<CR>
nnoremap <silent> ;e :<C-u>Denite menu:_<CR>
nnoremap <silent> ;c :<C-u>Denite command_history command<CR>
nnoremap <silent> ;y
      \ :<C-u>Denite register neoyank<CR>
xnoremap <silent> ;y
      \ :<C-u>Denite -default-action=replace register neoyank<CR>

nnoremap <silent> ,n
      \ :<C-u>Denite -resume -select=+1 -immediately -buffer-name=grep<CR>
nnoremap <silent> ,p
      \ :<C-u>Denite -resume -select=-1 -immediately -buffer-name=grep<CR>
'''
hook_source = '''
execute 'source' vimrc#join_path($VIMDIR, 'rc/plugins/denite.rc.vim')
'''

[[plugins]]
repo = 'Shougo/junkfile.vim'
depends = 'denite.nvim'
hook_add = '''
nnoremap <silent> <Leader>uj :<C-u>Denite junkfile:new junkfile<CR>
'''

[[plugins]]
repo = 'Shougo/neco-vim'
on_ft = 'vim'

[[plugins]]
repo = 'kana/vim-niceblock'
on_map = { x = '<Plug>' }
hook_add = '''
xmap I <Plug>(niceblock-I)
xmap A <Plug>(niceblock-A)
'''

[[plugins]]
repo = 'LeafCage/foldCC.vim'
on_path = '.*'

[[plugins]]
repo = 'thinca/vim-ref'
if = 'executable("lynx")'
on_map = { n = '<Plug>' }
hook_add = '''
nmap K <Plug>(ref-keyword)

let g:ref_lynx_use_cache = 1
let g:ref_lynx_start_linenumber = 0
let g:ref_lynx_hide_url_number = 0

" PHP
let g:ref_phpmanual_path = vimrc#join_path($_CACHE, 'refs/php-chunked-xhtml')

autocmd MyAutocmd FileType ref nnoremap <silent> <buffer> q :q<CR>
'''

[[plugins]]
repo = 'yyotti/eskk.vim'
rev = 'crvskkserv-support'
depends = 'vimproc.vim'
on_map = { ic = '<Plug>' }
hook_add = '''
imap <C-j> <Plug>(eskk:toggle)
cmap <C-j> <Plug>(eskk:toggle)
'''
hook_source = '''
let g:eskk#enable_completion = 0

if !exists('g:eskk#directory')
  let g:eskk#directory = expand('$_CACHE/eskk')
endif
let g:eskk#show_annotation = 1

" User dic
let g:eskk#dictionary = vimrc#join_path(g:eskk#directory, 'skk-jisyo')

let l:large_dic = ''
if filereadable('/usr/share/skk/SKK-JISYO.L')
  let l:large_dic = '/usr/share/skk/SKK-JISYO.L'
elseif filereadable('/usr/local/share/skk/SKK-JISYO.L')
  let l:lerge_dic = '/usr/share/skk/SKK-JISYO.L'
endif

if !empty(l:large_dic)
  let g:eskk#large_dictionary = {
        \   'path': l:large_dic,
        \   'sorted': 1,
        \   'encoding': 'euc-jp',
        \ }

endif

" google-ime-skk
if executable('google-ime-skk')
  let g:eskk#server = {
        \   'host': 'localhost',
        \   'port': 55100,
        \   'timeout': 1000,
        \ }
else
  let g:eskk#server = {
        \   'host': 'localhost',
        \   'timeout': 1000,
        \   'last_cr': 0,
        \ }
endif

autocmd MyAutocmd User eskk-initialize-pre call <SID>eskk_initial_pre()
function! s:eskk_initial_pre() abort "{{{
  let l:t = eskk#table#new('rom_to_hira*', 'rom_to_hira')
  call l:t.add_map('z ', "\u3000")
  call l:t.add_map('z(', "\uff08")
  call l:t.add_map('z)', "\uff09")
  call l:t.add_map('~', "\u301c")
  call eskk#register_mode_table('hira', l:t)
  unlet l:t
endfunction "}}}
'''

[[plugins]]
repo = 'kana/vim-operator-replace'
depends = 'vim-operator-user'
on_map = { nx = '<Plug>' }
hook_add = '''
map R <Plug>(operator-replace)
xmap p <Plug>(operator-replace)
'''

[[plugins]]
repo = 'rhysd/vim-operator-surround'
if = 1
depends = 'vim-operator-user'
on_map = { nx = '<Plug>' }
hook_add = '''
map <silent> ra <Plug>(operator-surround-append)
map <silent> rd <Plug>(operator-surround-delete)
map <silent> rc <Plug>(operator-surround-replace)
'''

[[plugins]]
repo = 'machakann/vim-sandwich'
if = 0
on_map = { nx = '<Plug>(operator-sandwich' }
hook_add = '''
let g:operator_sandwich_no_default_key_mappings = 1

nmap <silent> ra <Plug>(operator-sandwich-add)
nmap <silent> rd <Plug>(operator-sandwich-delete)
nmap <silent> rc <Plug>(operator-sandwich-replace)
'''

[[plugins]]
repo = 'airblade/vim-gitgutter'
on_path = '.*'
hook_add = '''
let g:gitgutter_sign_added = 'A'
let g:gitgutter_sign_modified = 'M'
let g:gitgutter_sign_removed = 'D'
let g:gitgutter_sign_removed_first_line = '~'
let g:gitgutter_sign_modified_removed = 'MD'

" Disable default mappings
let g:gitgutter_map_keys = 0
'''
hook_source = '''
autocmd MyAutocmd BufEnter * call <SID>gitgutter_mapping()
function! s:gitgutter_mapping() abort "{{{
  if !hasmapto('<Plug>GitGutterPrevHunk') && maparg('[c', 'n') ==# ''
    nmap <buffer> [c <Plug>GitGutterPrevHunk
  endif
  if !hasmapto('<Plug>GitGutterNextHunk') && maparg(']c', 'n') ==# ''
    nmap <buffer> ]c <Plug>GitGutterNextHunk
  endif

  if !hasmapto('<Plug>GitGutterTextObjectInnerPending')
        \ && maparg('ic', 'o') ==# ''
    omap <buffer> ic <Plug>GitGutterTextObjectInnerPending
  endif
  if !hasmapto('<Plug>GitGutterTextObjectOuterPending')
        \ && maparg('ac', 'o') ==# ''
    omap <buffer> ac <Plug>GitGutterTextObjectOuterPending
  endif
  if !hasmapto('<Plug>GitGutterTextObjectInnerVisual')
        \ && maparg('ic', 'x') ==# ''
    xmap <buffer> ic <Plug>GitGutterTextObjectInnerVisual
  endif
  if !hasmapto('<Plug>GitGutterTextObjectOuterVisual')
        \ && maparg('ac', 'x') ==# ''
    xmap <buffer> ac <Plug>GitGutterTextObjectOuterVisual
  endif
endfunction "}}}

highlight link GitGutterAdd diffAdded
highlight link GitGutterDelete diffRemoved
highlight link GitGutterChange qfLineNr
highlight link GitGutterChangeDelete GitGutterChange
'''

[[plugins]]
repo = 'easymotion/vim-easymotion'
depends = 'vim-repeat'
on_map = { nxo = '<Plug>' }
hook_add = '''
map ' <Plug>(easymotion-prefix)

map f <Plug>(easymotion-fl)
map t <Plug>(easymotion-tl)
map F <Plug>(easymotion-Fl)
map T <Plug>(easymotion-Tl)

map g/ <Plug>(easymotion-sn)
map g? <Plug>(easymotion-sn)

" map ; <Plug>(easymotion-next)

map 'f <Plug>(easymotion-fln)
map 't <Plug>(easymotion-tln)
map 'F <Plug>(easymotion-Fln)
map 'T <Plug>(easymotion-Tln)
'''
hook_source = '''
let g:EasyMotion_smartcase = 1
let g:EasyMotion_enter_jump_first = 1
let g:EasyMotion_space_jump_first = 1
let g:EasyMotion_startofline = 0
let g:EasyMotion_verbose = 0
'''

[[plugins]]
repo = 'lambdalisue/suda.vim'
on_path = 'suda://'

[[plugins]]
repo = 'simeji/winresizer'
on_cmd = [ 'WinResizerStartResize' ]
hook_add = '''
nnoremap <C-w>r :<C-u>WinResizerStartResize<CR>
'''
hook_post_source = '''
let g:winresizer_vert_resize = 5
if exists('g:winresizer_start_key')
  execute 'silent! unmap' g:winresizer_start_key
  unlet g:winresizer_start_key
endif
if exists('g:winresizer_gui_start_key')
  execute 'silent! unmap' g:winresizer_gui_start_key
  unlet g:winresizer_gui_start_key
endif
'''

[[plugins]]
repo = 'w0rp/ale'
if = 'has("nvim") || has("job") && has("channel") && has("timers")'
on_cmd = 'ALELint'  # for vim-ariline
on_path = '.*'
hook_source = '''
" let g:ale_lint_on_enter = 0
let g:ale_sign_error = "\u2a09"
let g:ale_sign_warning = "\u26a0"
let g:ale_lint_on_text_changed = 'never'
let g:ale_lint_on_insert_leave = 0

nmap <silent> [e <Plug>(ale_previous)
nmap <silent> [E <Plug>(ale_first)
nmap <silent> ]e <Plug>(ale_next)
nmap <silent> ]E <Plug>(ale_last)

if !exists('g:ale_linters')
  let g:ale_linters = {}
endif
if executable('golangci-lint')
  let g:ale_linters.go = [ 'golangci-lint' ]
  let g:ale_go_golangci_lint_options = join([
        \   '--tests',
        \   '--enable-all',
        \ ])
        "\   '--fast',
elseif executable('gometalinter')
  let g:ale_linters.go = [ 'gometalinter' ]
  let g:ale_go_gometalinter_options = join([
        \   '--tests',
        \   '--fast',
        \   '--enable=errcheck',
        \   '--enable=deadcode',
        \   '--enable=unparam',
        \ ])
        "\   '--enable=interfacer',
        "\   '--enable=misspell',
        "\   '--enable=unconvert',
else
  let g:ale_linters.go = [ 'go build', 'gofmt', 'golint', 'go vet' ]
endif

let stylelintrc =
      \ expand(vimrc#join_path($XDG_CONFIG_HOME, 'stylelint/stylelintrc.json'))
if filereadable(stylelintrc)
  let g:ale_css_stylelint_options = '--config ' . stylelintrc
endif

let tslintrc = expand(vimrc#join_path($XDG_CONFIG_HOME, 'tslint/tslint.json'))
if filereadable(tslintrc)
  let g:ale_typescript_tslint_config_path = tslintrc
endif

if executable(expand('$HOMEBREW_PREFIX/opt/php@5.6/bin/php'))
  let g:ale_php_php_executable = expand('$HOMEBREW_PREFIX/opt/php@5.6/bin/php')
endif
'''

[[plugins]]
repo = 'thinca/vim-quickrun'
on_map = { n = '<Plug>' }
hook_add = '''
nmap <silent> <Leader>r <Plug>(quickrun)
'''

[[plugins]]
repo = 'yyotti/vim-autoupload'
on_ft = [ 'php', 'smarty', 'css', 'js' ]
on_func = 'autoupload#init'
hook_source = '''
autocmd MyAutocmd BufWinEnter *.php,*.tpl,*.css,*.js
      \ call autoupload#init(0)
autocmd MyAutocmd BufWritePost *.php,*.tpl,*.css,*.js
      \ call autoupload#upload(0)
'''

[[plugins]]
repo = 'benjifisher/matchit.zip'
on_path = '.*'
hook_source = '''
if exists('g:loaded_matchit')
  unlet g:loaded_matchit
endif
'''

[[plugins]]
repo = 'osyo-manga/vim-precious'
depends = 'context_filetype.vim'
on_cmd = [ 'PreciousSwitch', 'PreciousReset' ]
hook_add = '''
autocmd MyAutocmd InsertEnter * PreciousSwitch
autocmd MyAutocmd InsertLeave * PreciousReset
'''
hook_source = '''
let g:precious_enable_switch_CursorMoved = { '*': 0 }
'''

[[plugins]]
repo = 'AndrewRadev/linediff.vim'
on_cmd = 'Linediff'
hook_add = '''
" Only visual mode
xnoremap <silent> D :Linediff<CR>
'''

[[plugins]]
repo = 'fatih/vim-go'
if = 'executable("go")'
on_ft = [ 'go', 'gohtmltmpl' ]
hook_source = '''
let g:go_fmt_fail_silently = 1
let g:go_highlight_types = 1
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_operators = 1
'''
hook_post_update = '''
call dein#source('vim-go')
GoInstallBinaries
'''

[[plugins]]
repo = 'eagletmt/neco-ghc'
if = 'executable("ghc-mod")'

[[plugins]]
repo = 'Yggdroot/indentLine'
on_path = '.*'
hook_source = '''
let g:indentLine_faster = 1

" let g:indentLine_color_gui = '#ffff00'
" let g:indentLine_bgcolor_gui = '#ff5f00'

let g:indentLine_concealcursor = 'nc'
let g:indentLine_conceallevel = 1
'''

[[plugins]]
repo = 'yyotti/denite-marks'
depends = 'denite.nvim'
on_source = 'denite.nvim'
on_cmd = 'Denite'
hook_add = '''
nnoremap <silent> ;m :<C-u>Denite marks<CR>
'''

[[plugins]]
repo = 'Shougo/neoyank.vim'
on_source = 'denite.nvim'
on_event = 'TextYankPost'

[[plugins]]
repo = 'tyru/open-browser.vim'
on_map = { nx = '<Plug>(openbrowser' }
on_source = 'previm'
hook_add = '''
nmap go <Plug>(openbrowser-smart-search)
vmap go <Plug>(openbrowser-smart-search)

nmap gs <Plug>(openbrowser-search)
vmap gs <Plug>(openbrowser-search)
'''
hook_source = '''
let g:openbrowser_no_default_menus = 1
'''

[[plugins]]
repo = 'mhartington/nvim-typescript'
if = 0
depends = 'deoplete.nvim'
build = './install.sh'
on_ft = 'typescript'
hook_source = '''
let g:nvim_typescript#default_signs = []
let g:nvim_typescript#default_mappings = 1
'''

[[plugins]]
repo = 'editorconfig/editorconfig-vim'
on_path = '.*'

[[plugins]]
repo = 'Shougo/defx.nvim'
# on_cmd = 'Defx'
hook_add = '''
nnoremap <silent> <Leader>fe :<C-u>Defx -buffer-name=defx <C-r>=expand('%:p:h')<CR> -search=<C-r>=expand('%:p')<CR><CR>
'''
hook_source = '''
" call defx#custom#column('mark', {
"      \ 'directory_icon': '▸',
"      \ 'readonly_icon': '✗',
"      \ 'selected_icon': '✓',
"      \ })
'''
