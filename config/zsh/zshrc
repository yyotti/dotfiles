if [[ ! -f $ZDOTDIR/.zshrc.zwc || $ZDOTDIR/.zshrc -nt $ZDOTDIR/.zshrc.zwc ]]; then
  zcompile $ZDOTDIR/.zshrc
fi

typeset -U path cdpath fpath manpath

# tmux {{{
if ${USE_TMUX:-true} && [[ $- =~ i ]] && [[ $TMUX == '' ]] && (( ${+commands[tmux]} )); then
  _tmux_conf="$XDG_CONFIG_HOME/tmux/tmux.conf"

  ID="$(tmux -f "$_tmux_conf" list-sessions 2>/dev/null)"
  if [[ $ID == '' ]]; then
    tmux -f "$_tmux_conf"  new-session
  elif (( ${+commands[fzf]} )); then
    create_new_session="Create New Session"
    ID="${create_new_session}:\n$ID"
    SEL_ID="$(echo "$ID" | fzf | cut -d: -f1)"
    if [[ $SEL_ID == $create_new_session ]]; then
      tmux -f "$_tmux_conf"  new-session
    else
      if [[ $SEL_ID != '' ]]; then
        tmux -f "$_tmux_conf"  attach-session -t "$SEL_ID"
      else
        : # Start normally
      fi
    fi
  else
    : # Start normally
  fi
fi

# }}}

function __is_wsl()
{
  [[ $(uname -a) =~ Linux && $(uname -a) =~ Microsoft ]]
}

# options {{{

# Changing Directories {{{

# ディレクトリ名だけでcd
setopt auto_cd

# cdしたらpushd
setopt auto_pushd

# ディレクトリが無ければ先頭に'~'をつけて処理
# setopt cdable_vars

# リンク先を絶対参照して'..'を処理
# setopt chase_dots

# symlinkを追跡してオリジナルにcdする
# setopt chase_links

# よりPOSIX標準に準拠する
setopt posix_cd

# 同じディレクトリは2度pushdしない
setopt pushd_ignore_dups

# pushdの+と-の意味を交換
# setopt pushd_minus

# pushdやpopdで出力を行わない
setopt pushd_silent

# 引数なしのpushdは'pushd $HOME'とする
setopt pushd_to_home

# }}}

# Completion {{{

# 補完の出力を上書きしない
# unsetopt always_last_prompt

# 完全な補完をしたらカーソルを末尾へ移動
setopt always_to_end

# 曖昧な補完で候補をリストアップしない
# unsetopt auto_list

# Tabキーを連打しても選択を移動しない
# unsetopt auto_menu

# 変数がディレクトリの場合に変数名をディレクトリ名として使用
# setopt auto_name_dirs

# 変数名の賢い補完
# unsetopt auto_param_keys

# ディレクトリを補完した場合は最後にスラッシュをつける
# unsetopt auto_param_slash

# ディレクトリの補完で付いたスラッシュを自動的に削除
# unsetopt auto_remove_slash

# Tabを3回押すまでリスト表示しない（ただし menu_complete が優先）
# setopt bash_auto_list

# エイリアスを別のコマンド名として処理する
# setopt complete_aliases

# カーソル部分から補完を開始する
# setopt complete_in_word

# 補完のグロブを展開せずに適合ワードをサイクルする
# setopt glob_complete

# 最初のコマンド補完時に path の内容をハッシュしない
# unsetopt hash_list_all

# 補完候補が一意の場合もリスト表示
# unsetopt list_ambiguous

# Tabを押して補完が成功しない時のビープを抑制
unsetopt list_beep

# コンパクトに表示
setopt list_packed

# 選択時に横方向に移動する
setopt list_rows_first

# ファイルの末尾に種別の識別記号をつける
# unsetopt list_types

# リスト表示の時にはじめから1つ挿入する
setopt menu_complete

# 曖昧さが残っていても補完を終了する
# unsetopt rec_exact

# }}}

# Expansion and Globbing {{{

# 不正なパターン時にエラーメッセージを表示しない
# unsetopt bad_pattern

# グロブを適切に処理する
# unsetopt bare_glob_qual

# ブレース展開式がただの文字列の場合に1文字ずつ展開
# setopt brace_ccl

# 大文字小文字を区別しない
# unsetopt case_glob

# 正規表現を使用しない
# unsetopt case_match

# csh形式のグロブを扱う
# setopt csh_null_glob

# =をグロブに使用できなくする
# unsetopt equals

# グロブに追加文字を使用する
# setopt extended_glob

# 数値計算を浮動小数点計算として扱う
# setopt force_float

# グロブを使用しない
# unsetopt glob

# 代入式の右辺で不明確なグロブ展開を使用する deprecated
# setopt glob_assign

# 明確な場合はファイル名先頭のドットを必要としない
# setopt glob_dots

# 変数の内容も展開に使用する
# setopt glob_subst

# sや&の展開修飾マッチングをパターンマッチにする
setopt hist_subst_pattern

# ブレース展開を無効にする
# setopt ignore_braces

# コマンド最初の閉じ大カッコ（}）が必要なくなる。ただし最後のコマンドに';'がないとエラーになる。
# setopt ignore_close_braces

# ksh形式のグロブを使用する
# setopt ksh_glob

# オプションの=以降の補完を可能にする
setopt magic_equal_subst

# グロブ展開後のディレクトリには末尾に'/'を付加
setopt mark_dirs

# マルチバイト文字を扱わない
# unsetopt multibyte

# ファイル生成パターンのエラーを表示しない
# unsetopt no_match

# エラーの表示の代わりにパターンを除去する
# setopt null_glob

# ファイル名生成を辞書順ではなく数値順にする
# setopt numeric_glob_sort

# 展開に含まれる配列を別々に展開する
# setopt rc_expand_param

# 正規表現マッチング（param =~ regexp）でPCREを使用可能にする
# unsetopt rematch_pcre

# kshやshのグロブを使用する
# setopt sh_glob

# 定義されていない変数を空文字の変数として扱わない（エラーになる）
# unsetopt unset

# 関数内の変数がグローバルとして定義されていたら警告を出す
# setopt warn_create_global

# }}}

# History {{{

# ヒストリファイルをセッションごとに上書きする
# unsetopt append_history

# csh形式のヒストリ拡張を使用しない
# unsetopt bang_hist

# ヒストリにコマンド実行時刻を含める
setopt extended_history

# 書き込みリダイレクトで既存ファイルの上書きを許可する
# setopt hist_allow_clobber

# 存在しないヒストリの場合ビープで通知する
unsetopt hist_beep

# ヒストリが削られる場合、以前入力した同じものを先に削除する
# setopt hist_expire_dups_fist

# 書き込み中のヒストリファイルをロックする際に fcntl を使用する
setopt hist_fcntl_lock

# ヒストリ検索時に以前見たものを2度表示しない
setopt hist_find_no_dups

# 以前と同じコマンドはヒストリに保存しない
setopt hist_ignore_all_dups

# 直前のコマンドと同じコマンドはヒストリに保存しない
setopt hist_ignore_dups

# 行頭がスペースのコマンドはヒストリに保存しない
setopt hist_ignore_space

# ヒストリファイルの形式を変更する
# setopt hist_lex_words

# ヒストリから関数定義を除去する
setopt hist_no_functions

# ヒストリコマンドをヒストリから取り除く
setopt hist_no_store

# ヒストリ保存時に余分な空白を除去する
setopt hist_reduce_blanks

# ヒストリを一旦コピーファイルに保存しない
# unsetopt hist_save_by_copy

# ヒストリファイルに書き出すときに以前のコマンドと同じものを除去する
setopt hist_save_no_dups

# ヒストリコマンドを直接実行しない
# setopt hist_verify

# ヒストリをヒストリファイルに即座に書き込む
setopt inc_append_history

# ヒストリ書き込み時間をヒストリファイルに追加する
# setopt inc_append_history_time

# ヒストリの読み出しと書き込みを同時に行う
setopt share_history

# }}}

# Initializations {{{

# すべての変数を自動的にexportする
# setopt all_export

# エクスポートフラグ(-x)をもつ変数が自動的にグローバル(-g)にならない
# unsetopt global_export

# 起動時に /etc/zshenv を除く /etc 以下の設定ファイル群を読み込まない
# unsetopt global_rcs

# 起動時に /etc/zshenv を除く全ての設定ファイルを読み込まない
# unsetopt rcs

# }}}

# Input/Output {{{

# エイリアスを拡張しない
# unsetopt aliases

# リダイレクトによる入出力制御
# unsetopt clobber

# スペルミスの修正をする
setopt correct

# コマンド行の全ての引数に対してスペルミスの修正を行う
# setopt correct_all

# スペルミスの修正時にDvorak配列として修正する
# setopt dvorak

# フロー制御(Ctrl+S,Ctrl+Q)を無効化する
unsetopt flow_control

# EOFを読み込んでも終了しない
# setopt ignore_eof

# 対話的シェルでも#以降をコメントとみなす
setopt interactive_comments

# コマンドの場所をその場所の最初の実行時にハッシュしない
# unsetopt hash_cmds

# コマンドのハッシュ時にそれを含むディレクトリをハッシュしない
# unsetopt hash_dirs

# 実行権限が付与されているコマンド以外はハッシュしない
# setopt hash_executables_only

# メールファイルにアクセスがあると警告を出す
setopt mail_warning

# コマンド名に/が含まれていてもそれを含めたパスの検索を行う
setopt path_dirs

# 効果不明
# setopt path_script

# マルチバイト文字を処理する
# setopt print_eight_bit

# 終了コード($?)を表示する
# setopt print_exit_value

# シングルクォート内のシングルクォートを許可する
# setopt rc_quotes

# 'rm *'の実行時に警告を表示しない
# setopt rm_star_silent

# 'rm *'の実行前に10秒間の猶予を与える
# setopt rm_star_wait

# 省略形式のループ(forなど)を許可しない
# unsetopt short_loops

# バッククォートの数が合わない場合に最後のバッククォートを無視する
# setopt sun_keyboard_hack

# }}}

# Job Control {{{

# disownコマンドでジョブテーブルから除去したjobに自動的にCONTシグナルを送信する
setopt auto_continue

# サスペンドしたjobをそのコマンド名で再開する
setopt auto_resume

# バックグラウンドのjobの優先度を下げない
if __is_wsl; then
  unsetopt bg_nice
fi

# バックグラウンドjobがある際にzshを終了しても何も警告しない
# unsetopt check_jobs

# 実行中のjobがある場合にzshを終了するとそのjobにHUPシグナルを送信しない（道連れにする）
# unsetopt hup

# jobsで表示されるjobリストを冗長にする
# setopt long_list_jobs

# jobコントロールを許可する（インタラクティブシェルではデフォルト）
# setopt monitor

# バックグラウンドjobが終了しても即座に通知しない
# unsetopt notify

# POSIX標準に準拠したjobコントロールを使用する
# setopt posix_jobs

# }}}

# Prompting {{{

# プロンプトで!を特殊文字として扱わない
# unsetopt prompt_bang

# プロンプトで改行コードの無い行を出力しない
# unsetopt prompt_cr

# prompt_crで出力されなかった行を反転文字で通知
# unsetopt prompt_sp

# プロンプトで%を特殊文字として扱わない
# unsetopt prompt_percent

# プロンプトで拡張変数などを利用する
setopt prompt_subst

# コマンド実行時に右プロンプトの表示を削除する
setopt transient_rprompt

# }}}

# Scripts and Functions {{{
# 互換性を考えるとこの種類のオプションを変更するのは好ましくないので省略
# }}}

# Shell Emulation {{{
# 互換性を考えるとこの種類のオプションを変更するのは好ましくないので省略
# }}}

# Shell State {{{
# 互換性を考えるとこの種類のオプションを変更するのは好ましくないので省略
# }}}

# Zsh Line Editor (ZLE) {{{

# ZLEのエラー時にビープで通知しない
unsetopt beep

# 通常では使用されない特殊記号を正しく表示する
# setopt combining_chars

# Emacsのキーバインディングを使用する
# setopt emacs

# ZLEをOverstrikeモードで起動
# setopt overstrike

# シングルラインエディットにする
# setopt single_line_zle

# Viのキーバインディングを使用する
setopt vi

# ZLEを使用する（インタラクティブシェルではデフォルト）
setopt zle

# }}}

# }}}

# autoload {{{
autoload -Uz \
  history-search-end \
  colors \
  add-zsh-hook \
  is-at-least \
  async
# }}}

# Completions {{{
# git
if (( ${+commands[git]} )); then
  # git-now
  if (( ${+commands[git-now]} )); then
    for p in $(ghq root --all); do
      fpath=($p/github.com/iwata/git-now/etc(N-/) $fpath)
    done
  fi

  # git-xxx original subcommands
  zdotdir=$(readlink $ZDOTDIR || echo $ZDOTDIR)
  fpath=($zdotdir/../scripts/git/completions(N-/) $fpath)
fi

# ghq
if (( ${+commands[ghq]} )); then
  fpath=($GOPATH/src/github.com/motemen/ghq/zsh(N-/) $fpath)
fi

# gist
if (( ${+commands[gist]} )); then
  fpath=($GOPATH/src/github.com/b4b4r07/gist/misc/completion/zsh(N-/) $fpath)
fi

# fd
if (( ${+commands[fd]} )); then
  fpath=($XDG_DATA_HOME/fd/autocomplete(N-/) $fpath)
fi

zstyle ':completion:*' cache-path $XDG_CACHE_HOME/zsh/completion-cache
zstyle ':completion:*' group-name ''
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*' use-cache yes
zstyle ':completion:*' verbose yes
zstyle ':completion:*:default' menu select=2
zstyle ':completion:*:descriptions' format '%F{011}%d%f'
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:options' description 'yes'
zstyle ':completion:*:warnings' format 'No matches for: %d'

# Shift+Tab : reverse menu
bindkey '^[[Z' reverse-menu-complete

zstyle ':completion:*:sudo:*' command-path /usr/local/sbin \
                                           /usr/local/bin \
                                           /usr/sbin \
                                           /usr/bin \
                                           /sbin \
                                           /bin

# }}}

# plugins {{{

function __chmod_dir()
{
  if __is_wsl; then
    # only wsl
    find "$1" -type d -name '.git' -prune -o -type d -exec chmod 755 {} \;
  fi
}

export ZPLUG_HOME=$XDG_CACHE_HOME/zsh/zplug
if [[ ! -d $ZPLUG_HOME ]]; then
  {
    if [[ $(uname -a) =~ Linux && $(uname -a) =~ Microsoft ]]; then
      echo unsetopt bg_nice
    fi
    curl -sL https://raw.githubusercontent.com/zplug/installer/master/installer.zsh
  } | zsh

  __chmod_dir $ZPLUG_HOME
fi
source $ZPLUG_HOME/init.zsh

zplug 'zplug/zplug', \
  hook-build:'zplug --self-manage', \
  dir:"$ZPLUG_HOME"
zplug 'zsh-users/zsh-completions', \
  hook-build:'__chmod_dir "$ZPLUG_REPOS/zsh-users"; zplug clear', \
  hook-load:'fpath=($ZPLUG_REPOS/zsh-users/zsh-completions/src $fpath)'
zplug 'mollifier/zload', \
  hook-build:'__chmod_dir "$ZPLUG_REPOS/mollifier"'
zplug 'mafredri/zsh-async', \
  hook-build:'__chmod_dir "$ZPLUG_REPOS/mafredri"'

if [[ ! -f $ZPLUG_CACHE_DIR/interface ]] \
  || [[ $ZPLUG_LOADFILE -nt $ZPLUG_CACHE_DIR/interface ]] \
  || ! zplug check --verbose; then
  printf 'Install? [y/N]: '
  if read -q; then
    echo
    zplug install
  fi
fi
zplug load

# }}}

# FuzzyFinder {{{
_FZF_HOME="$GOPATH/src/github.com/junegunn/fzf"
if [[ $- =~ i && -d $_FZF_HOME ]]; then
  export FZF_TMUX=1

  # TODO agなどコマンドを分ける(like denite.nvim)
  export FZF_CTRL_T_COMMAND="command fd --type=file --color=never --hidden --follow --exclude=.git"
  # export FZF_ALT_C_COMMAND="command find -L . -mindepth 1 -path '*/\\.*' -prune -o -type d -print 2> /dev/null | cut -b3-"

  # TODO プロンプトに入力している文字列であらかじめ絞りたい

  source "$_FZF_HOME/shell/completion.zsh"
  source "$_FZF_HOME/shell/key-bindings.zsh"

  function fzf-ghq-widget()
  {
    setopt localoptions pipefail 2>/dev/null

    local dir
    dir=( $(ghq list --full-path | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} $FZF_DEFAULT_OPTS --tiebreak=index --bind=ctrl-r:toggle-sort" $(__fzfcmd)) )
    local ret=$?

    if [[ $dir == '' ]]; then
      zle redisplay
      return 0
    fi

    LBUFFER="${LBUFFER}${dir}"
    zle redisplay
    typeset -f zle-line-init >/dev/null && zle zle-line-init
    return $ret
  }
  zle -N fzf-ghq-widget
  bindkey '^G' fzf-ghq-widget

  function fzf-vim-plugins-widget()
  {
    local _vim_plugins_dir="$XDG_CACHE_HOME/vim/pack/bundle/opt"
    local dir=''
    local ret=0

    if [[ -d $_vim_plugins_dir ]]; then
      setopt localoptions pipefail 2>/dev/null

      dir=( $(fd --color=never --type=d --max-depth=1 . "${_vim_plugins_dir}" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} $FZF_DEFAULT_OPTS --tiebreak=index --bind=ctrl-r:toggle-sort" $(__fzfcmd)) )
      ret=$?
    fi

    if [[ $dir == '' ]]; then
      zle redisplay
      return 0
    fi

    LBUFFER="${LBUFFER}${dir}"
    zle redisplay
    typeset -f zle-line-init >/dev/null && zle zle-line-init
    return $ret
  }
  zle -N fzf-vim-plugins-widget
  bindkey '^V' fzf-vim-plugins-widget

  function fzf-git-branch-widget()
  {
    setopt localoptions pipefail 2>/dev/null

    local _branches=$(git branch -v 2>/dev/null)
    local _branch=$(echo "$_branches" | FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-40%} $FZF_DEFAULT_OPTS --tiebreak=index --bind=ctrl-r:toggle-sort" $(__fzfcmd))
    local _ret=$?

    if [[ $_branch == '' ]]; then
      zle redisplay
      return 0
    fi

    LBUFFER="${LBUFFER}$(echo "$_branch" | awk '{print $1}' | sed "s/.* //")"
    zle redisplay
    typeset -f zle-line-init >/dev/null && zle zle-line-init
    return $_ret
  }
  zle -N fzf-git-branch-widget
  bindkey '^B' fzf-git-branch-widget

  # Change default keybinds
  bindkey '^F' fzf-file-widget
  bindkey -r '\ec'
fi
# }}}

# aliases {{{
alias ls='ls -hF --color=auto --time-style="+%Y/%m/%d %H:%M:%S"'
alias ll='ls -l'
alias la='ll -A'
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
alias sudo='sudo '
alias lspath='echo "${PATH//:/\n}"'
if (( ${+commands[tig]} )); then
  alias tiga='tig --all'
  alias tigr='tig refs'
  alias tigs='tig status'
fi

if (( ${+commands[fzf]} )); then
  alias -g F='| fzf'
fi

if (( ${+commands[rg]} )); then
  alias rg='rg --no-heading --column'
fi

if (( ${+commands[nkf]} )); then
  # エイリアスじゃないけど・・・
  function urlenc()
  {
    echo "$1" | nkf -wWMQ | tr = %
  }
  function urldec()
  {
    echo "$1" | nkf -w --url-input
  }
fi
# }}}

# histories {{{
HISTFILE=$XDG_CACHE_HOME/zsh/history
HISTSIZE=10000
SAVEHIST=10000

zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end

# Ctrl+P/N : history search
bindkey '^P' history-beginning-search-backward-end
bindkey '^N' history-beginning-search-forward-end
# }}}

# colors {{{

# LS_COLORSが設定されているなら補完にも同じ色を設定する
if [[ $LS_COLORS != '' ]]; then
  zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
fi

# 256色のカラーコードを表示する
function listcolors() # {{{
{
  echo standard colors:
  for c in {000..015}; do
    echo -n "\e[38;5;${c}m $c\e[0m"
    [[ $((c%6)) == 5 ]] && echo
  done
  echo

  echo

  echo 256 colors:
  for c in {016..255}; do
    echo -n "\e[38;5;${c}m $c\e[0m"
    [[ $(($((c-16))%6)) == 5 ]] && echo
  done
  echo
}
# }}}

# }}}

# prompt {{{
function __is_root() # {{{
{
  [[ $UID == 0 ]]
  return $?
}
# }}}

function __init_color() # {{{
{
  local _var_name=$1
  local _default_color=$2
  local _root_color=${3:-$_default_color}

  if [[ $_var_name == '' ]]; then
    return
  fi

  if __is_root; then
    eval ${_var_name}=$_root_color
  else
    eval ${_var_name}=$_default_color
  fi

  if [[ $(eval echo \$$_var_name) != '' ]]; then
    eval ${_var_name}_start="%F{\$$_var_name}"
    eval ${_var_name}_end='%f'
  else
    eval ${_var_name}_start=''
    eval ${_var_name}_end=''
  fi
}
# }}}

function __prompt_setup() # {{{
{
  # Initialize color variables
  # PROMPT
  __init_color prompt_color_cwd 010
  __init_color prompt_color_user 006 009
  __init_color prompt_color_host 012
  __init_color prompt_color_symbol 255
  __init_color prompt_color_symbol_error 196

  __init_color prompt_git_separator 243
  __init_color prompt_git_bare_repo 001
  __init_color prompt_git_in_git_dir 001
  __init_color prompt_git_branch 002
  __init_color prompt_git_branch_detached 009
  __init_color prompt_git_merge_behind 228
  __init_color prompt_git_merge_ahead 135
  __init_color prompt_git_staged 010
  __init_color prompt_git_unstaged 196
  __init_color prompt_git_untracked 011
  __init_color prompt_git_invalid 009
  __init_color prompt_git_stashed 039
  __init_color prompt_git_operation 196
  __init_color prompt_git_upstream 039
  __init_color prompt_git_upstream_behind 228
  __init_color prompt_git_upstream_ahead 135
  __init_color prompt_git_unmerged 011
  __init_color prompt_git_now 196

  # PROMPT2
  __init_color prompt2_color 006

  # SPROMPT
  __init_color sprompt_color 011

  # Prevent percentage showing up if output doesn't end with a newline.
  export PROMPT_EOL_MARK=''

  if [[ $prompt_newline == '' ]]; then
    typeset -g prompt_newline=$'\n%{\r%}'
  fi
  if [[ $prompt_sep == '' ]]; then
    typeset -g prompt_sep="${prompt_git_separator_start}|${prompt_git_separator_end}"
  fi

  async

  add-zsh-hook precmd __prompt_precmd

  prompt_username=
  if [[ $SSH_CONNECTION != '' || $UID == 0 ]]; then
    prompt_username+='${prompt_color_user_start}%n${prompt_color_user_end}'
  fi
  if [[ $SSH_CONNECTION != '' ]]; then
    prompt_username+='@${prompt_color_host_start}%m${prompt_color_host_end}'
  fi

  typeset -g prompt_symbol=$(
  echo -en '%(?.${prompt_color_symbol_start}.${prompt_color_symbol_error_start})'
  echo -en '%#'
  echo -en '%(?.${prompt_color_symbol_end}.${prompt_color_symbol_error_end})'
  )

  PROMPT2='${prompt2_color_start}(%_)>${prompt2_color_end} '
  SPROMPT='${sprompt_color_start}%r is correct?${sprompt_color_end} [%Uy%ues/%UN%uo/%Ua%ubort/%Ue%udit]:'
}
# }}}

function __prompt_precmd() # {{{
{
  __prompt_async_tasks

  # print the preprompt
  __prompt_preprompt_render "precmd"
}
# }}}

function __prompt_async_tasks() # {{{
{
  setopt localoptions noshwordsplit

  # initialize async worker
  if ! ${prompt_async_init:-false}; then
    async_start_worker "prompt" -u -n
    async_register_callback "prompt" __prompt_async_callback
    typeset -g prompt_async_init=true
  fi

  typeset -gA prompt_git_info

  local -H MATCH MBEGIN MEND
  if [[ ${prompt_git_info[pwd]} == '' || $PWD != ${prompt_git_info[pwd]}* ]]; then
    # stop any running async jobs
    async_flush_jobs "prompt"

    unset prompt_git_repo
    unset prompt_git_dirty
    unset prompt_git_upstream
    unset prompt_git_now_stash
    prompt_git_info[top]=
    prompt_git_info[git_dir]=
  fi
  unset MATCH MBEGIN MEND

  async_job "prompt" __prompt_async_git_info $PWD

  if [[ $prompt_git_info[git_dir] == '' ]]; then
    return
  fi

  __prompt_async_refresh
}
# }}}

function __prompt_async_refresh() # {{{
{
  setopt localoptions noshwordsplit

  async_job "prompt" __prompt_async_git_repo $PWD ${prompt_git_info[git_dir]}
  async_job "prompt" __prompt_async_git_dirty $PWD
  async_job "prompt" __prompt_async_git_upstream $PWD
  async_job "prompt" __prompt_async_git_now_stash $PWD
}
# }}}

function __prompt_async_git_repo() { # {{{
  setopt localoptions noshwordsplit
  local _dir=$1

  # use cd -q to avoid side effects of changing directory, e.g. chpwd hooks
  builtin cd -q $_dir

  local -A _res
  local _git_dir=$2

  local _repo
  _repo=( $(command git rev-parse --is-inside-git-dir --is-bare-repository HEAD 2>/dev/null) )

  _res[is_inside_gitdir]=${_repo[1]}
  _res[is_bare]=${_repo[2]}
  _res[sha]=${_repo[3]}

  local -A _op_branch_detached
  _op_branch_detached=("${(Q@)${(z)$(__get_op_branch_detached "$_git_dir" "${_res[sha]}")}}")
  _res[operation]=${_op_branch_detached[operation]}
  _res[branch]=${_op_branch_detached[branch]}
  _res[is_detached]=${_op_branch_detached[detached]}


  # unmerged
  local _counts
  _counts=( $(command git rev-list --count --left-right master...HEAD 2>/dev/null) )

  if [[ $#_counts == 0 ]]; then
    _res[behind]=0
    _res[ahead]=0
  else
    _res[behind]=${_counts[1]}
    _res[ahead]=${_counts[2]}
  fi

  print -r - "${(@kvq)_res}"
}
# }}}

function __get_op_branch_detached() # {{{
{
  local _git_dir=$1
  local _sha=$2

  local _branch=''
  local _step=-1
  local _total=-1
  local _operation=''
  local _is_detached=false

  if [[ -d $_git_dir/rebase-merge ]]; then
    _branch=$(cat "$_git_dir/rebase-merge/head-name" 2>/dev/null)
    _step=$(cat "$_git_dir/rebase-merge/msgnum" 2>/dev/null)
    _total=$(cat "$_git_dir/rebase-merge/end" 2>/dev/null)
    if [[ -f $_git_dir/rebase-merge/interactive ]]; then
      _operation='REBASE-i'
    else
      _operation='REBASE-m'
    fi
  else
    if [[ -d $_git_dir/rebase-apply ]]; then
      _step=$(cat "$_git_dir/rebase-apply/next" 2>/dev/null)
      _total=$(cat "$_git_dir/rebase-apply/last" 2>/dev/null)
      if [[ -f $_git_dir/rebase-apply/rebasing ]]; then
        _branch=$(cat "$_git_dir/rebase-apply/head-name" 2>/dev/null)
        _operation='REBASE'
      elif [[ -f $_git_dir/rebase-apply/applying ]]; then
        _operation='AM'
      else
        _operation='AM/REBASE'
      fi
    elif [[ -f $_git_dir/MERGE_HEAD ]]; then
      _operation='MERGING'
    elif [[ -f $_git_dir/CHERRY_PICK_HEAD ]]; then
      _operation='CHERRY-PICKING'
    elif [[ -f $_git_dir/REVERT_HEAD ]]; then
      _operation='REVERTING'
    elif [[ -f $_git_dir/BISECT_LOG ]]; then
      _operation='BISECTING'
    fi
  fi

  if [[ $_step -ge 0 && $_total -ge 0 ]]; then
    _operation="$_operation $_step/$_total"
  fi

  if [[ $_branch == '' ]]; then
    _branch=$(command git symbolic-ref HEAD 2>/dev/null)
    if [[ $? != 0 ]]; then
      _is_detached=true
      _branch=$(command git describe --contains --all HEAD 2>/dev/null)
      if [[ $? != 0 ]]; then
        if [[ $_sha != '' ]]; then
          _branch=${_sha[0,8]}
        else
          _branch=''
        fi
      fi
    fi
  fi

  local -A _res
  _res[branch]=${_branch#refs/heads/}
  _res[operation]=$_operation
  _res[detached]=$_is_detached

  print -r - ${(@kvq)_res}
}
# }}}

function __prompt_async_git_dirty() { # {{{
  setopt localoptions noshwordsplit
  local _dir=$1

  # use cd -q to avoid side effects of changing directory, e.g. chpwd hooks
  builtin cd -q $_dir

  local _status
  _status=("${(f)$(command git status --porcelain --ignore-submodules -unormal 2>/dev/null)}")
  local _ret=$?
  if [[ $_ret == 0 && $#_status > 0 && ${_status[1]} != '' ]]; then
    local _untracked=${(M)#_status:#\?\? *}
    local _staged=${(M)#_status:#?  *}
    local _unstaged=${(M)#_status:# ? *}
    local _invalid=$(( $#_status - $_untracked - $_staged - $_unstaged ))

    print -- $_staged $_unstaged $_untracked $_invalid
  fi

  return $_ret
}
# }}}

function __prompt_async_git_upstream() { # {{{
  setopt localoptions noshwordsplit
  local _dir=$1

  # use cd -q to avoid side effects of changing directory, e.g. chpwd hooks
  builtin cd -q $_dir

  local -A _res
  _res[upstream]=
  _res[behind]=0
  _res[ahead]=0

  local _counts
  _counts=( $(command git rev-list --count --left-right '@{upstream}'...HEAD 2>/dev/null) )
  if [[ $? != 0 ]]; then
    print -r - "${(@kvq)_res}"
    return
  fi

  if [[ $#_counts != 0 ]]; then
    _res[behind]=${_counts[1]}
    _res[ahead]=${_counts[2]}

    _res[upstream]=$(command git rev-parse --abbrev-ref '@{upstream}' 2>/dev/null)
  fi

  print -r - "${(@kvq)_res}"
}
# }}}

function __prompt_async_git_now_stash() { # {{{
  setopt localoptions noshwordsplit
  local _dir=$1

  # use cd -q to avoid side effects of changing directory, e.g. chpwd hooks
  builtin cd -q $_dir

  local _stash=$(command git stash list | grep -c '')
  if [[ $? != 0 ]]; then
    _stash=0
  fi

  local _now=0
  if (( ${+commands[git-now]} )); then
    _now=$(command git now grep | grep -c '')
    if [[ $? != 0 ]]; then
      _now=0
    fi
  fi

  print -- $_stash $_now
}
# }}}

function __prompt_async_callback() # {{{
{
  setopt localoptions noshwordsplit

  local _job=$1
  local _code=$2
  local _output=$3
  local _exec_time=$4
  local _next_pending=$6
  local _do_render=false

  case $_job in
    __prompt_async_git_info)
      typeset -gA prompt_git_info

      if [[ $_output == '' ]]; then
        prompt_git_info[top]=
        prompt_git_info[git_dir]=
      else
        # parse output (z) and unquote as array (Q@)
        local -A _info
        _info=("${(Q@)${(z)_output}}")
        local -H MATCH MBEGIN MEND
        if [[ $_info[top] == $prompt_git_info[top] ]]; then
          if [[ $prompt_git_info[pwd] == ${PWD}* ]]; then
            prompt_git_info[pwd]=$PWD
          fi
        else
          prompt_git_info[pwd]=$PWD
        fi
        unset MATCH MBEGIN MEND

        if [[ ${_info[git_dir]} != '' ]]; then
          __prompt_async_refresh
        fi

        # always update .git dir and toplevel
        prompt_git_info[top]=$_info[top]
        prompt_git_info[git_dir]=$_info[git_dir]
      fi

      _do_render=true
      ;;
    __prompt_async_git_repo)
      local _prev_repo=$prompt_git_repo
      if [[ $_output == '' ]]; then
        unset prompt_git_repo
      else
        local -A _repo
        _repo=("${(Q@)${(z)_output}}")

        local _branch_prefix
        if ${_repo[is_bare]}; then
          _branch_prefix="${prompt_git_bare_repo_start}BARE:${prompt_git_bare_repo_end}"
        elif ${_repo[is_inside_gitdir]}; then
          _branch_prefix="${prompt_git_in_git_dir_start}GIT:${prompt_git_in_git_dir_end}"
        fi

        local _branch
        if ${_repo[is_detached]}; then
          _branch="${prompt_git_branch_detached_start}${_repo[branch]}${prompt_git_branch_detached_end}"
        else
          _branch="${prompt_git_branch_start}${_repo[branch]}${prompt_git_branch_end}"
        fi

        local _operation
        if [[ ${_repo[operation]} != '' ]]; then
          _operation=" <${prompt_git_operation_start}${_repo[operation]}${prompt_git_operation_end}>"
        fi

        local _ahead=${_repo[ahead]}
        local _behind=${_repo[behind]}
        if [[ $_ahead > 0 ]]; then
          _ahead="${prompt_git_merge_ahead_start}+${_repo[ahead]}${prompt_git_merge_ahead_end}"
        else
          _ahead=
        fi
        if [[ $_behind > 0 ]]; then
          _behind="${prompt_git_merge_behind_start}-${_repo[behind]}${prompt_git_merge_behind_end}"
        else
          _behind=
        fi
        typeset -g prompt_git_repo="${_behind}${_branch_prefix}${_branch}${_ahead}${_operation}"
      fi

      if [[ $_prev_repo != $prompt_git_repo ]]; then
        _do_render=true
      fi
      ;;
    __prompt_async_git_dirty)
      local _prev_dirty=$prompt_git_dirty
      if [[ $_output == '' ]]; then
        unset prompt_git_dirty
      else
        local _staged
        local _unstaged
        local _untracked
        local _invalid

        echo "$_output" | read _staged _unstaged _untracked _invalid

        if [[ $_staged > 0 ]]; then
          _staged="${prompt_git_staged_start}+${prompt_git_staged_end}"
        else
          _staged=
        fi
        if [[ $_unstaged > 0 ]]; then
          _unstaged="${prompt_git_unstaged_start}*${prompt_git_unstaged_end}"
        else
          _unstaged=
        fi
        if [[ $_untracked > 0 ]]; then
          _untracked="${prompt_git_untracked_start}?${prompt_git_untracked_end}"
        else
          _untracked=
        fi
        if [[ $_invalid > 0 ]]; then
          _invalid="${prompt_git_invalid_start}!${prompt_git_invalid_end}"
        else
          _invalid=
        fi
        typeset -g prompt_git_dirty="${_staged}${_unstaged}${_untracked}${_invalid}"
      fi

      if [[ $_prev_dirty != $prompt_git_dirty ]]; then
        _do_render=true
      fi
      ;;
    __prompt_async_git_upstream)
      local _prev_upstream=$prompt_git_upstream
      if [[ $_output == '' ]]; then
        unset prompt_git_upstream
      else
        local -A _up
        _up=("${(Q@)${(z)_output}}")

        local _upstream
        local _ahead
        local _behind
        if [[ ${_up[upstream]} != '' ]]; then
          _upstream="${prompt_git_upstream_start}${_up[upstream]}${prompt_git_upstream_end}"
        else
          _upstream=
        fi
        if [[ ${_up[ahead]} > 0 ]]; then
          _ahead="${prompt_git_upstream_ahead_start}+${_up[ahead]}${prompt_git_upstream_ahead_end}"
        else
          _ahead=
        fi
        if [[ ${_up[behind]} > 0 ]]; then
          _behind="${prompt_git_upstream_behind_start}-${_up[behind]}${prompt_git_upstream_behind_end}"
        else
          _behind=
        fi
        typeset -g prompt_git_upstream="${_behind}${_upstream}${_ahead}"
      fi

      if [[ $_prev_upstream != $prompt_git_upstream ]]; then
        _do_render=true
      fi
      ;;
    __prompt_async_git_now_stash)
      local _prev_now_stash=$prompt_git_now_stash
      if [[ $_output == '' ]]; then
        unset prompt_git_now_stash
      else
        local _stash
        local _now

        echo "$_output" | read _stash _now

        if [[ $_stash > 0 ]]; then
          _stash="${prompt_git_stashed_start}\$${_stash}${prompt_git_stashed_end}"
        else
          _stash=
        fi
        if [[ $_now > 0 ]]; then
          _now="${prompt_git_now_start}N${_now}${prompt_git_now_end}"
        else
          _now=
        fi
        typeset -g prompt_git_now_stash="${_now}${_stash}"
      fi

      if [[ $_prev_now_stash != $prompt_git_now_stash ]]; then
        _do_render=true
      fi
      ;;
    *)
      ;;
  esac

  if (( _next_pending )); then
    if $_do_render; then
      typeset -g prompt_async_render_requested=true
      return
    fi
  fi

  if ${prompt_async_render_requested:-$_do_render}; then
    __prompt_preprompt_render
  fi
  unset prompt_async_render_requested
}
# }}}

function __prompt_async_git_info() # {{{
{
  if ! (( ${+commands[git]} )); then
    return
  fi

  setopt localoptions noshwordsplit
  builtin cd -q $1 2>/dev/null

  local _repo
  _repo=( $(command git rev-parse --git-dir --show-toplevel 2>/dev/null) )
  if [[ $? != 0 ]]; then
    return
  fi

  local -A _info
  _info[git_dir]=$(readlink -f "${_repo[1]}")
  _info[top]=${_repo[2]}

  print -r - ${(@kvq)_info}
}
# }}}

function __prompt_preprompt_render() # {{{
{
  setopt localoptions noshwordsplit

  local -a _preprompt_parts

  _preprompt_parts+=('${prompt_color_cwd_start}%~${prompt_color_cwd_end}')

  # git status info
  typeset -gA prompt_git_info
  local -a _git_info_parts
  if [[ $prompt_git_info[git_dir] != '' ]]; then
    _git_info_parts+=('${prompt_git_repo}')
    if [[ $prompt_git_now_stash != '' ]]; then
      _git_info_parts+=('${prompt_git_now_stash}')
    fi
    if [[ $prompt_git_dirty != '' ]]; then
      _git_info_parts+=('${prompt_git_dirty}')
    fi
    if [[ $prompt_git_upstream != '' ]]; then
      _git_info_parts+=('${prompt_git_upstream}')
    fi
  fi

  if [[ $#_git_info_parts > 0 ]]; then
    _preprompt_parts+=("(${(j.${prompt_sep}.)_git_info_parts})")
  fi

  local -ah _ps1
  _ps1=(
  $prompt_newline
  ${(j. .)_preprompt_parts}
  $prompt_newline
  "$prompt_username"
  $prompt_symbol
  ' '
  )

  PROMPT="${(j..)_ps1}"

  local _expanded_prompt="${(S%%)PROMPT}"
  if [[ $1 != precmd ]] && [[ $prompt_last_prompt != $_expanded_prompt ]]; then
    zle && zle .reset-prompt
  fi

  typeset -g prompt_last_prompt=$_expanded_prompt
}
# }}}

__prompt_setup
# }}}

# local {{{
if [[ -f $ZDOTDIR/zshrc.local ]]; then
  source $ZDOTDIR/zshrc.local
fi
# }}}

if which zprof >/dev/null 2>&1; then
  zprof | less
fi
